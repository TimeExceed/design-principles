\documentclass[UTF8,lualatex]{ctexbeamer}
\usepackage{graphicx}
\usepackage{minted}
\usepackage{tabu}
\usepackage{amsmath}

\setbeamertemplate{note page}[plain]
% $BEAMER_NOTES

\title{\kaishu 陶大讲软件工程}
  \author{陶大}
  \institute{YITU tech}
  \date{\small
    Created in July.\ 2019,\\
    Updated in May.\ 2021}

\newcommand{\pagequote}[2]{
  \Large
  \begin{quotation}
      #1
  \end{quotation}
  \flushright\normalsize --- {#2}
}

\renewcommand{\emph}[1]{\structure{#1}}

\begin{document}
\songti

\begin{frame}
\titlepage
\end{frame}

% \begin{frame}
%   \frametitle{Outline}
%   \tableofcontents
% \end{frame}

\begin{frame}
    \begin{block}{我是谁？}
        \begin{itemize}
            \item 上交计算机博士
                \begin{itemize}
                    \item 理论计算机方向。对几乎所有软件领域都有涉猎：软件工程、编程语言、数据库、分布式系统$\cdots$
                \end{itemize}
            \item 野生经济学家
                \begin{itemize}
                    \item 拍卖论和机制设计
                \end{itemize}
        \end{itemize}
    \end{block}
\end{frame}

\section{破题}

\begin{frame}
    \pagequote{
        Large-system programming has over the past decade been such a tar pit,
        and many great and powerful beasts have thrashed violently in it...
        No one thing seems to cause the difficulty -- any particular paw can be pulled away.}
        {Frederick P. Brooks Jr.,\\``The Mythical Man-Month"}
\end{frame}

\begin{frame}
    \frametitle{工程是什么?}
    \pagequote{
        The creative application of scientific principles to \only<1-2>{design or develop}\only<3->{\textcolor{blue}{design or develop}} structures, machines, apparatus, or manufacturing processes, or works utilizing them singly or in combination;
        or to construct or operate the same with \only<1-3>{full cognizance of their design}\only<4->{\textcolor{orange}{full cognizance of their design}};
        or to \only<1-4>{forecast their behavior}\only<5->{\textcolor{red}{forecast their behavior}} under specific operating conditions;
        all as respects an \only<1>{intended function}\only<2->{\textcolor{green}{intended function}}, economics of operation and safety to life and property.}
        {The American Engineers' Council for Professional Development}
\end{frame}

\note{
    \begin{enumerate}
        \item intended function: 价值创造
        \item design or develop: 实现手段
        \item full cognizance of their design: 要看文档（如果有的话）。
            一般来讲，动手之前先看tutorial已经胜过80\%的码农了。
        \item forecast their behavior: 我一直强调，程序不是写出来通过测试就结束了。
            这个标准太低了。
            代码本质上要回答问题：在什么情况下如何行为。
    \end{enumerate}
}

\begin{frame}
    \frametitle{软件工程的差异}
    \pagequote{\noindent\center 软件是活的！}{陶大}
\end{frame}

\section{论可靠性}

\begin{frame}
    \frametitle{传统工程的可靠性理论}
    \begin{center}
        \large
        MTTF = Mean Time To Failure
    \end{center}
\end{frame}

\note{
    \begin{itemize}
        \item 传统工程的可靠性理论的基础是材料的物理老化。
            软件当然也要考虑硬盘坏道、GPU烧坏甚至紫外线翻掉内存一个bit，
            但是，一般来讲，软件作为一个逻辑的构建，是不会老化的。
    \end{itemize}
}

\begin{frame}
    \frametitle{软件工程的可靠性理论}
    \pagequote{What doesn't kill you, makes you stronger.}{Friedrich W. Nietzsche}
\end{frame}

\note{
    \begin{itemize}
        \item 软件的可靠性取决于从设计者到开发者对风险的识别。
            说人话，他们见识过多少坑、经历过多少坑决定了软件的可靠性。
        \item 软件更像生命体。
        \item BTW, 我不相信软件工程师存在什么35岁线。
            个别的情况会有，总会存在不需要可靠性的场景。
            行业整体上不可能。
    \end{itemize}
}

\begin{frame}
    \frametitle{传统工程的可靠性理论}
    \[
    F=1-(1-p)^n
    \]
    \begin{center}
        \begin{tabu}{l}
            $F$: 系统出错的概率；\\
            $p$: 每次改动出错的概率；\\
            $n$: 改动的次数。
        \end{tabu}
    \end{center}
\end{frame}

\note{
    \begin{itemize}
        \item 所以，要想得到一个稳定的系统，外行人自然的直觉是\textbf{不折腾}。
            只要不停的修bug，总会得到一个很稳的系统。
            这是对的。
        \item 然而这种看法忽略了软件最大的两项风险：
            \begin{enumerate}
                \item 对软件来讲，没人用是比挂掉更大的风险。
                \item 软件作为一个逻辑构建，其可靠性是有前提假设的。
                    比如疫情期间“扶我起来”的COBOL程序员们。
            \end{enumerate}
            而任何一个被人使用的系统，人总会不断挑战其边界。
            所以，\textbf{为了稳，你必须要折腾}。
        \item 所以，软件工程在实操上的核心问题是：
            如何低成本、低风险地折腾。
    \end{itemize}
}

\begin{frame}
    \frametitle{软件工程的可靠性理论}
    \pagequote{It takes all the running you can do, to keep in the same place.}
        {``Red Queen hypothesis" by Van Valen\\originated from Lewis Carroll}
\end{frame}

\section{论设计}

\begin{frame}
    \frametitle{传统工程的设计}
    \pagequote{Architecture is the design activity of the architect.}{Wikipedia}
\end{frame}

\note{
    软件工程最初从建筑学习了很多。
    现在回顾，基本上是条弯路。
    两个区别：
    \begin{enumerate}
        \item 建筑师不搬砖。
        \item 建筑设计一旦完成便不可变。
    \end{enumerate}
}

\begin{frame}
    \frametitle{软件的设计}
    \begin{columns}[t]
        \begin{column}{0.45\textwidth}
            \begin{block}{微观设计}
                要点在适度抽象
                \begin{itemize}
                    \item 从代码中来，回代码中去。
                    \item 不要怕改代码，不要怕改得多。但是要回答，怎么控制风险。
                    \item 多语言合力：动静结合、业务胶水与能力构件结合。
                \end{itemize}
            \end{block}
        \end{column}
        \begin{column}{0.45\textwidth}
            \begin{block}{宏观设计}
                要点在商业战略
                \begin{itemize}
                    \item 谁花钱、谁用、什么条件下用、解决什么问题
                    \item 不同的业务语言意味着不同的选择压力, esp.,\ 对多样性的要求
                \end{itemize}
            \end{block}
        \end{column}
    \end{columns}
\end{frame}

\note{
    \begin{itemize}
        \item 宏观设计、微观设计的工作范围约略对应概要设计和详细设计。
            但是指导思想不同。
        \item 微观设计是涌现出来的，不是设计出来的。
            抽象的目的是模块化，模块化的目的是专业化。
            不是为了代码复用。
            代码复用是一种架构手段；复用率是一个观察指标；但不是一个值得追求的目标。
        \item SOLID是工具，不是不可违背的天条。
            抽象的关键是\textbf{适度}，适业务需求的度。
        \item 一门静态语言提供能力构件，提供高性能、低资源消耗。
            一门动态语言提供业务胶水，解决快速业务定制、动态行为。
            典型是浏览器。
            用进化论的黑话来讲，不同的语言应对不同的进化压力。
            识别不同的进化压力需要对业务的深度认知。
    \end{itemize}
}

\subsection{微观设计}

\begin{frame}
    \frametitle{微观设计}
    \begin{center}
        \includegraphics[height=0.7\textheight]{refactor.png}
    \end{center}
    \note[item]{
        这本书讲的是：微观设计怎样从代码中涌现出来。
        但是我们今天不讲这本书。
    }
\end{frame}

\begin{frame}
    \frametitle{两个OOP}
    \begin{columns}[t]
        \begin{column}{0.45\textwidth}
            \begin{block}{众多对象通过通讯连接在一起}
                \begin{itemize}
                    \item 这个方向诞生了Erlang、Akka、Go
                \end{itemize}
            \end{block}
            \note[item]{
                函数调用也是通讯。
            }
        \end{column}
        \begin{column}{0.45\textwidth}
            \begin{block}{通过类和继承安排各个对象的拓扑结构}
                \begin{itemize}
                    \item 这个方向导致柏拉图式设计
                \end{itemize}
            \end{block}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]
    \frametitle{柏拉图主义、集合论与面向对象设计}
    \begin{block}{如何设计一个“鸟”类？}
        “鸟”要不要\mintinline{java}{fly()}方法？
        \begin{itemize}
            \item 这里有一只鸭子。鸭子是鸟。鸟会飞。所以鸭子会飞。
            \item 然而，鸵鸟不会飞、蝙蝠会飞。
        \end{itemize}
        \note[item]{
            柏拉图主义认为存在一个理念世界。
            理念世界里的东西都是完美的。
            现实世界的万物都是理念世界的不完美投射。
            类-继承体系的设计的问题正在于削不完美现实的脚适完美理念的履。
            \begin{itemize}
                \item 要么，你放一个空实现。
                    那么调用者，你不知道你调用了一个对象的一个方法会不会炸。
                \item 要么，你要做一个大而无当不知所云的抽象。
                    比如junit的\mintinline{java}{setUp}/\mintinline{java}{tearDown}。
            \end{itemize}

            其中的关键是，\textbf{完美的理念，by definition，是完美的，没有进化的余地}。
            毕其功于一役，我是不信的。
        }
        \note[item]{
            我批评的是作为建模工具的柏拉图主义面向对象设计。
            继承作为实现层面的语言工具，我不反对。
            虽然我不认为代码复用是一个值得追求的目标。
        }
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{OOP的解药}
    \begin{block}{面向接口(Trait-based)设计}
        接口体现能力，不谈理念，不套圈圈。
        \begin{itemize}
            \item \mintinline{java}{Flyable}接口。鸭子、蝙蝠实现这个接口，鸵鸟不实现这个接口。
            \item 抽象代数的思维
        \end{itemize}
        \note[item]{
            我不管你底下具体是什么，只要你具备群公理，你就是一个群，我就可以用。
        }
        \note[item]{
            在这个模式下，难题是怎么提炼接口。
            不同的抽象思路会导致不同的接口。
            这里没有对错。
        }
    \end{block}
    \begin{block}{函数式编程}
        函数式编程提供新的抽象思路，更关注数据流，而非控制流。
        \note[item]{
            这里不展开讲FP。
            参见我其他的slides。
        }
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{On Architectures}
    \pagequote{To the man who only has a hammer, everything he encounters begins to look like a nail.}{Abraham Maslow}
\end{frame}

\note{
    我做技术选型，提供更丰富的抽象能力一定是重要的考虑因素。
    这就是我认为rust/c++好过go/java的原因，也是k8s好过spring cloud的原因。

    但是大家知道，我在基础设施部主持的开发项目都选go，没有选rust。
    现实决策需要因时制宜、因地制宜的权衡。
}

\subsection{宏观设计与组织结构}

\begin{frame}
    \frametitle{宏观设计与组织结构}
    \pagequote{
        Organizations which design systems\ldots~are constrained to produce designs
        which are copies of the communication structures of these organizations.}
        {M. Conway}
\end{frame}

\begin{frame}
    \frametitle{宏观设计与组织结构}
    \pagequote{宏观设计是伪装成技术决策的商业决策。}{陶大}
\end{frame}

\begin{frame}
    \frametitle{宏观设计与组织结构}
    \begin{block}{宏观设计须回答}
        \begin{enumerate}
            \item 各部分的用户、客户、价值何在？
            \item 基于前者的判断，回答选择压力何在(比如多样性)？
            \item 满足前述两者的资源模型如何？
            \item 前述所有诸款的动态如何？
        \end{enumerate}
    \end{block}
    \note[item]{
        更准确地说，是\textbf{战略路线在技术战线的体现}。
        所以，没有脱离业务的宏观设计。
    }
    \note[item]{
        宏观设计里无需避讳因人设岗。
    }
\end{frame}

\begin{frame}
    \frametitle{宏观设计与组织结构}
    \begin{corollary}
        压力类型不同的组件不宜放在一个团队内。
    \end{corollary}
    \note[item]{
        这里有团队能力模型的问题、团队文化的问题。
        最主要的问题是吸血-扯后腿的问题。
    }
    \note[item]{
        作为成本中心和作为利润中心，面对的压力类型不同。

        成本中心强调控制支出、控制风险。
        比方说IT。
        挣钱不是IT的工作，花钱才是。
        但是老板不会让乱花钱。
        所以会有一堆流程来约束花钱。
    }
\end{frame}

\section{案例试讲}
\subsection{测试}

\begin{frame}
    \pagequote{
        Software testing is an investigation conducted to provide stakeholders 
        with \emph{information about the quality} of the software product or service under test.}
        {Wikipedia}
\end{frame}

\note{
    \begin{itemize}
        \item Wikipedia的观点反对软件测试是quality assurance。
            Bug都是架构师设计出来、开发写出来的，修也是他们去修，测试在任何意义上都无法“保障质量”。
            \begin{itemize}
                \item 整个quality assurance的理论体系构建在MTTF之上，从建筑业和流水线工业品借鉴过来的。
                    软件工程早期的弯路之一。
            \end{itemize}
        \item 然而这个观点仍然是错的。
            本质上，\emph{软件作为纯逻辑的存在，其质量可以感受，不可度量}。
        \item 没有两个bug是完全一样的。如果有，那bug不在那个层面。
    \end{itemize}
}

\begin{frame}
    \pagequote{
        每个软件都有bug。只是我不知道它们在哪里。}
        {陶大}
\end{frame}

\begin{frame}
    \frametitle{测试}
    \begin{block}{是什么？}
        测试回答一个软件/系统，在指定环境下\emph{应当}如何行为。
    \end{block}
    \begin{block}{谁来干？}
        测试的职责\emph{应当分散}
        \begin{itemize}
            \item 产品
            \item 架构师
            \item 工程师
        \end{itemize}
    \end{block}
\end{frame}

\note{
    \begin{itemize}
        \item 产品。
            定义上，测试和PRD没有本质区别。
        \item 架构师。
            架构师是业务语言到技术语言的翻译官。
            那么把关键场景翻译成测试也很合理。
        \item 工程师。
            自己准备写什么自己没有个B数吗？
            单元测试尤其合理。
    \end{itemize}
}

\begin{frame}
    \pagequote{
        干掉测试团队！}
        {陶大}
\end{frame}

\section{总结}

\begin{frame}
    \frametitle{总结}
    \begin{block}{~}
        \begin{itemize}
            \item 软件是活的
                \begin{itemize}
                    \item 可靠性
                \end{itemize}
            \item 微观设计
                \begin{itemize}
                    \item OOP, trait-based, FP
                \end{itemize}
            \item 宏观设计和组织结构
                \begin{itemize}
                    \item 战略路线在技术战线的体现
                \end{itemize}
            \item 案例
                \begin{itemize}
                    \item 不应当存在测试团队
                \end{itemize}
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Q\&A}
    \begin{alertblock}{Q}
        软件中开发流程和成本之间怎么平衡？如果碰到有类似ASPICE审查要求时，怎么取舍？
    \end{alertblock}
    \begin{block}{A}
        \begin{itemize}
            \item “开发流程和成本”分别指什么？
            \item CMMI定义软件研发的要素，至于怎么实现这些要素，它不管。
                ASPICE是这样吗？
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Q\&A}
    \begin{alertblock}{Q}
        提升软件质量行之有效的方法？
    \end{alertblock}
    \begin{block}{A}
        \begin{itemize}
            \item 要在观念：质量是所有人的事，除了测试。
            \item 观念更新之后，方可谈具体的技术，比如fuzzy testing、Coq等。
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Q\&A}
    \begin{alertblock}{Q}
        汽车领域软件开发方式的变革趋势？
    \end{alertblock}
    \begin{block}{A}
        无可评论。
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Q\&A}
    \begin{alertblock}{Q}
        \only<1>{
            关于需求：
            \begin{enumerate}
                \item 在写需求时，什么时候应该聚焦在前端的，最浅层次，最通俗易懂的需求上？什么时候应该从设计层面来写需求，考虑各种意外情况下如何丰富完善自己的需求？
                \item 需求书对于细节、对于参数如何设计、对于极端情况没有考虑到的，是应该由设计人员来规避、完善需求文档；还是责任属于需求人员本身，严格来讲应该让写需求的人自己去完善需求文档？
                \item 需求文档更新确认，设计文档攥写，模型或者代码的开发应该把握什么共同开发的节奏才能起到如下效果： a) 前期考虑细致的设计提高了开发效率  b) 设计文档及时补充完善，方便个人总结与同事之间的评审 c) 需求、细节的修改不会导致严重的设计文档返工
            \end{enumerate}
        }
        \only<2>{
            抽象来讲：谁应该写需求文档？应该怎么写？
        }
    \end{alertblock}
    \begin{block}<2>{A}
        \begin{itemize}
            \item 需求文档并非最终交付物的一部分。因此是overhead，非benefit。
            \item 关于需求文档的需求分析：用户、客户分别是谁？价值创造如何？约束条件如何？
            \item 一个建议：谁对最终交付物负责，谁来决定谁写以及形式。
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Q\&A}
    \begin{alertblock}{Q}
        关于设计：
        \begin{enumerate}
            \item 架构是什么？架构设计、分析的输出物是什么？一般格式如何？
            \item 架构设计一般考虑哪些内容？怎么体现在输出物里？
            \item 常说高内聚，低耦合，有没有什么实例来说明一下好的架构和不那么好的？
        \end{enumerate}
    \end{alertblock}
    \begin{block}{A}
        \begin{itemize}
            \item 架构师是从业务语言到技术语言的翻译。
                架构是业务的战略路线在技术领域的体现。
            \item 考虑的重点：系统的风险何在？系统各组件演化的压力如何？
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Q\&A}
    \begin{alertblock}{Q}
        关于测试：
        \begin{enumerate}
            \item 测试中会碰到，自己评估下来不会有问题的地方，实际测试发现存在问题，您认为导致这种现象的原因是什么？ 是否认为，自认为无聊的、没有意义的、耗费时间较长的时间、往复的测试是有必要的，是需要调整心态去坚决执行的。
            \item 关于“改了一行注释也需要重新测试”这样的言论；
            \item 软件测试（MIL/HIL）非常耗时，业界的自动化做法有哪些？
        \end{enumerate}
    \end{alertblock}
    \begin{block}{A}
        \begin{itemize}
            \item 测试是spec，不是quality assurance。
            \item 不要试图和人性对抗。该工具解决的问题写工具去解决。
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Q\&A}
    \begin{alertblock}{Q}
        关于管理
        \begin{enumerate}
            \item 能否介绍下贵司在协同开发时是如何进行版本号和分支管理的呢？
        \end{enumerate}
    \end{alertblock}
    \begin{block}{A}
        \begin{itemize}
            \item 可以。但大概率没用。
            \item 你们用什么版本管理软件？
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Q\&A}
    \begin{alertblock}{Q}
        关于管理
        \begin{enumerate}
            \item 现场调试时发现总会有重复的问题出现在不同版本(或不同的项目)中，相关问题bug只是简单用excel记录，没有恰当的跟踪起来。请问有什么样的开源软件来管控此类问题？
        \end{enumerate}
    \end{alertblock}
    \begin{block}{A}
        \begin{itemize}
            \item JIRA
            \item GitLab的issue
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Q\&A}
    \begin{alertblock}{Q}
        关于管理
        \begin{enumerate}
            \item 当软件需求存在变更的可能性时，前期软件需求撰写、后期软件设计、开发要注意什么？
        \end{enumerate}
    \end{alertblock}
    \begin{block}{A}
        \begin{itemize}
            \item leader/架构师必须懂业务。
                \begin{itemize}
                    \item 骑自行车的比方
                \end{itemize}
            \item 原型开发：快速体验、快速反馈、快速迭代
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Q\&A}
    \begin{alertblock}{Q}
        关于管理
        \begin{enumerate}
            \item 多人开发的时候，如何把控软件的质量？除了（1）peer review；（2）给出详尽的设计文档，规范，限制可发挥范围？
        \end{enumerate}
    \end{alertblock}
    \begin{block}{A}
        \begin{itemize}
            \item 何为“多人”？老司机带新人？一群老司机分头开发feature？一群老司机共同开发同一个feature？多人和单人有何不同？
            \item peer review不解决质量问题，它解决信息孤岛。质量提升是副作用。
            \item 文档、规范都是overhead，因人而立、因人而废。
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \pagequote{What's your problem?}{Robin Li}
\end{frame}

\end{document}
